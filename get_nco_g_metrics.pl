#!/usr/bin/perl
### Created by Karthikeyan P, Date: 18-April-2024, Version: 1.0, Initial release
### Script Name: get_nco_g_metrics.pl 
### This Script will fetch the Performance KPI's from running instance of Netcool Omnibus(JDBC, Uni & Bi-directional ObjectServer) Gateways.
### Script Accepts following input parameters.
### gateways.zip package generated by the command $OMNIHOME/bin/nco_isadc -record /home/netcool/tws_script/gateways/gateways_isadc.props -outputzip  /home/netcool/tws_script/gateways/nco_gateways.zip
### Type of Gateway as Selection from Terminal.
### Name of the Gateway as Terminal Input.
##
use strict;
use warnings;
use Cwd qw(cwd);
use File::Path qw(rmtree);
use Data::Dumper;
use JSON::PP;

#### FUNCTIONS ####
#
sub extract_pkg {
  my ($pkg, $tempdir) = @_;
  system("unzip $pkg -d $tempdir > /dev/null 2>&1")
}

sub get_jdbc_gw_version {
  my ($version_out_file) = @_;
  my $version_var;
  open(my $version_out_FH, $version_out_file) || die "Unable to open the file !.";
  my @version_lines = <$version_out_FH>;
  chop(@version_lines);
  foreach my $vline (@version_lines) { ## Extracting only the First Entry.
    $version_var.=$vline;
   }
 chomp($version_var);
 close($version_out_FH);
 #print $version_var;
 my @var_match = $version_var =~ m/Netcool\/OMNIbus\ Gateway\ nco\-g\-jdbc\ \(com\.ibm\.tivoli\.omnibus\.integrations\.nco-g-jdbc\)\W+Version:\W(\d+\.\d+\.\d+\.\d+\W\(\d+\.\d+\.\d+\.\d+\))/;
 if (length(@var_match) == 1) { ## This Should return only one value.
    return $var_match[0];
    }
 else {
   return "99";
    }
 }

sub get_os_gw_version {
  my ($version_out_file) = @_;
  my $version_var;
  open(my $version_out_FH, $version_out_file) || die "Unable to open the file !.";
  my @version_lines = <$version_out_FH>;
  chop(@version_lines);
  foreach my $vline (@version_lines) { ## Extracting only the First Entry.
    $version_var.=$vline;
   }
 chomp($version_var);
 close($version_out_FH);
 #print $version_var;
 my @var_match = $version_var =~ m/com\.ibm\.tivoli\.omnibus\.core\)\W+Version:\W+(\d+\.\d+\.\d+\.\d+\W\(\d+.\d+.\d+.\d+\_\d+\))/;
   if (length(@var_match) == 1) { ## This Should return only one value.
     return $var_match[0];
       }
   else {
     return "99";
        }
   }

sub get_jdbc_gw_props {
  my($gw_props_file) = @_;
  my(@jdbc_connections, @jdbc_resync, @jdbc_cache, @jdbc_gw_mode, @jdbc_max_batch);
  my %kpis_out = ();
  open(my $props_out_FH, $gw_props_file) || die "Unable to open the file !.";
  my @props_lines = <$props_out_FH>;
  chop(@props_lines);
  foreach my $prop (@props_lines) { ## Extracting only the First Entry.
    if($prop =~ m/^Gate.Jdbc.Connections/) {
       @jdbc_connections = $prop =~ m/Gate.Jdbc.Connections\W+(\d+)/;
       $kpis_out{"Jdbc_Connections"} = $jdbc_connections[0];
     }
    elsif($prop =~ m/^Gate.Jdbc.ResyncMode/) {
      @jdbc_resync = $prop =~ m/Gate.Jdbc.ResyncMode\W+(\w+)/;
      $kpis_out{"Jdbc_ResyncMode"} = $jdbc_resync[0];
     }
    elsif($prop =~ m/Gate.CacheHashTblSize/) {
      @jdbc_cache = $prop =~ m/Gate.CacheHashTblSize\W+(\d+)/;
      $kpis_out{"CacheHashTblSize"} = $jdbc_cache[0];
     }
    elsif($prop =~ m/Gate.Jdbc.Mode/) {
      @jdbc_gw_mode = $prop =~ m/Gate.Jdbc.Mode\W+(\w+)/;
      $kpis_out{"Jdbc_Mode"} = $jdbc_gw_mode[0];
     }
    elsif($prop =~ m/Gate.Jdbc.MaxBatchSize/) {
      @jdbc_max_batch = $prop =~ m/Gate.Jdbc.MaxBatchSize\W+(\d+)/;
      $kpis_out{"Jdbc_MaxBatchSize"} = $jdbc_max_batch[0];
     }
  }  
  #print Dumper(\@jdbc_connections);
  #print Dumper(\@jdbc_resync);
  #print Dumper(\@jdbc_cache);
  #print Dumper(\@jdbc_gw_mode);
  #print Dumper(\@jdbc_max_batch);
  #return $jdbc_connections[0], $jdbc_resync[0], $jdbc_cache[0], $jdbc_gw_mode[0], $jdbc_max_batch[0];
  return %kpis_out;
}

sub get_uni_gw_props {
  my($gw_props_file) = @_;
  my(@uni_resync_enable, @uni_resync_type, @uni_writer_buffsize, @uni_refresh_cache);
  my %kpis_out = ();
  open(my $props_out_FH, $gw_props_file) || die "Unable to open the file !.";
  my @props_lines = <$props_out_FH>;
  chop(@props_lines);
  foreach my $prop (@props_lines) { ## Extracting only the First Entry.
    if($prop =~ m/^Gate.Resync.Enable/) {
       @uni_resync_enable = $prop =~ m/Gate.Resync.Enable\W+(\w+)/;
       $kpis_out{"ReSync_Enable"} = $uni_resync_enable[0];
     }
    elsif($prop =~ m/^Gate.Resync.Type/) {
      @uni_resync_type = $prop =~ m/Gate.Resync.Type\W+(\w+)/;
      $kpis_out{"Resync_Type"} = $uni_resync_type[0];
     }
    elsif($prop =~ m/Gate.Writer.Buffersize/) {
      @uni_writer_buffsize = $prop =~ m/Gate.Writer.Buffersize\W+(\d+)/;
      $kpis_out{"Writer_BufferSize"} = $uni_writer_buffsize[0];
     }
    elsif($prop =~ m/Gate.Writer.RefreshCacheOnUpdate/) {
      @uni_refresh_cache = $prop =~ m/Gate.Writer.RefreshCacheOnUpdate\W+(\w+)/;
      $kpis_out{"Writer_RefreshCacheOnUpdate"} = $uni_refresh_cache[0];
     }
 
  }
  return %kpis_out;
}

sub get_bi_gw_props {
  my($gw_props_file) = @_;
  my(@bi_resync_enable, @bi_resync_type, @ObjServA_writer_buffsize, @ObjServA_refresh_cache, @ObjServB_writer_buffsize, @ObjServB_refresh_cache);
  my %kpis_out = ();
  open(my $props_out_FH, $gw_props_file) || die "Unable to open the file !.";
  my @props_lines = <$props_out_FH>;
  chop(@props_lines);
  foreach my $prop (@props_lines) { ## Extracting only the First Entry.
    if($prop =~ m/^Gate.Resync.Enable/) {
       @bi_resync_enable = $prop =~ m/Gate.Resync.Enable\W+(\w+)/;
       $kpis_out{"Resync_Enable"} = $bi_resync_enable[0];
     }
    elsif($prop =~ m/^Gate.Resync.Type/) {
      @bi_resync_type = $prop =~ m/Gate.Resync.Type\W+(\w+)/;
      $kpis_out{"Resync_Type"} = $bi_resync_type[0];
     }
    elsif($prop =~ m/Gate.ObjectServerA.Buffersize/) {
      @ObjServA_writer_buffsize = $prop =~ m/Gate.ObjectServerA.Buffersize\W+(\d+)/;
      $kpis_out{"ObjectServerA_Buffersize"} = $ObjServA_writer_buffsize[0];
     }
    elsif($prop =~ m/Gate.ObjectServerA.RefreshCacheOnUpdate/) {
      @ObjServA_refresh_cache = $prop =~ m/Gate.ObjectServerA.RefreshCacheOnUpdate\W+(\w+)/;
      $kpis_out{"ObjectServerA_RefreshCacheOnUpdate"} = $ObjServA_refresh_cache[0];
     }
    elsif($prop =~ m/Gate.ObjectServerB.Buffersize/) {
      @ObjServB_writer_buffsize = $prop =~ m/Gate.ObjectServerB.Buffersize\W+(\d+)/;
      $kpis_out{"ObjectServerB_Buffersize"} = $ObjServB_writer_buffsize[0];
     }
    elsif($prop =~ m/Gate.ObjectServerB.RefreshCacheOnUpdate/) {
      @ObjServB_refresh_cache = $prop =~ m/Gate.ObjectServerB.RefreshCacheOnUpdate\W+(\w+)/;
      $kpis_out{"ObjectServerB_RefreshCacheOnUpdate"} = $ObjServB_refresh_cache[0];
     }
	

  }
  return %kpis_out;
}

####
#
### MAIN ###
my $script_dir = cwd;
my %gw_kpis = ();
my($nco_g_version);
my $script_name = "get_nco_g_metrics.pl";
my $gw_kpi_file = "$script_dir/nco_g_kpi.out";
my $temp_dir = "$script_dir/temp";
if ( -d  $temp_dir) {
   rmtree("$temp_dir");
}
mkdir $temp_dir, 0755 or die "Failed to create directory: $!";
#my($nco_g_package, $gw_name) = @ARGV;
my $nco_g_package = $ARGV[0];
print "Select the Type of Gateway\n";
print "1. JDBC\n";
print "2. ObjectServerGateway-UniDirectional\n";
print "3. ObjectServerGateway-BiDirectional\n";
print "Enter 1 or 2 or 3: ";
my $gw_type = <STDIN>;
chomp($gw_type);
print "Enter the Name of the gateway: ";
my $gw_name = <STDIN>;
chomp($gw_name);
print "gateway name: $gw_name\n";
extract_pkg($nco_g_package, $temp_dir);
my $version_output_file = "$temp_dir/netcool/nco_id.stdout";
my $gw_props = "$temp_dir/netcool/omnibus/etc/$gw_name.props";
#print "$gw_props\n";
if($gw_type == 1) {
  %gw_kpis = get_jdbc_gw_props($gw_props);
  $nco_g_version = get_jdbc_gw_version($version_output_file);
  $gw_kpis{"jdbc_gw_version"} = $nco_g_version;
 }
elsif($gw_type == 2) {
  %gw_kpis = get_uni_gw_props($gw_props);
  $nco_g_version = get_os_gw_version($version_output_file);
  $gw_kpis{"os_uni_gw_version"} = $nco_g_version;
 }
elsif($gw_type == 3) {
  %gw_kpis = get_bi_gw_props($gw_props);
  $nco_g_version = get_os_gw_version($version_output_file);
  $gw_kpis{"os_bi_gw_version"} = $nco_g_version;
 }
#print Dumper(\%jdbc_gw_kpis);
my $json =  encode_json(\%gw_kpis);
open(my $KPI_FH, ">$gw_kpi_file") || die "Unable to open the file for writing!.";
  print $KPI_FH "$json\n";
close($KPI_FH);

